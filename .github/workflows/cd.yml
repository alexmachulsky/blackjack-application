name: CD

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Triggered only when the CI workflow completes successfully on the main branch.
# Branch protection on `main` must require CI to pass before merge, so by the
# time this runs the code is already lint-clean, tested, and security-scanned.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
on:
    workflow_run:
        workflows: ["CI"]
        branches: [main]
        types: [completed]

# One CD run at a time â€” never deploy two versions simultaneously
concurrency:
    group: cd-${{ github.ref }}
    cancel-in-progress: false # finish current deploy before starting next

env:
    REGISTRY: ghcr.io
    # Images: ghcr.io/<owner>/blackjack-backend and blackjack-frontend
    BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/blackjack-backend
    FRONTEND_IMAGE: ghcr.io/${{ github.repository_owner }}/blackjack-frontend

jobs:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Guard: abort if CI failed or was cancelled
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ci-gate:
        name: CI Gate
        runs-on: ubuntu-latest
        if: ${{ github.event.workflow_run.conclusion == 'success' }}
        steps:
            - name: CI passed â€” proceeding with CD
              run: echo "CI workflow succeeded. Starting CD pipeline."

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Job 1: Build & push images to GHCR
    #
    # Tags applied to every image:
    #   ghcr.io/<owner>/<image>:sha-<short-commit>   â† immutable reference
    #   ghcr.io/<owner>/<image>:latest               â† convenience pointer
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    build-and-push:
        name: Build & Push Images
        runs-on: ubuntu-latest
        needs: ci-gate

        # Required so GITHUB_TOKEN can write packages (GHCR)
        permissions:
            contents: read
            packages: write

        outputs:
            # Passed downstream so deploy jobs pull exactly the right image
            image_tag: ${{ steps.meta.outputs.short_sha }}

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set short SHA
              id: meta
              run: echo "short_sha=sha-$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Log in to GHCR
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            # â”€â”€ Backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            - name: Build & push backend
              uses: docker/build-push-action@v5
              with:
                  context: ./backend
                  push: true
                  tags: |
                      ${{ env.BACKEND_IMAGE }}:${{ steps.meta.outputs.short_sha }}
                      ${{ env.BACKEND_IMAGE }}:latest
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  # Embed build metadata as OCI labels for traceability
                  labels: |
                      org.opencontainers.image.revision=${{ github.sha }}
                      org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

            # â”€â”€ Frontend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            - name: Build & push frontend
              uses: docker/build-push-action@v5
              with:
                  context: ./frontend
                  target: production
                  push: true
                  tags: |
                      ${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.short_sha }}
                      ${{ env.FRONTEND_IMAGE }}:latest
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  labels: |
                      org.opencontainers.image.revision=${{ github.sha }}
                      org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Job 2: Deploy to PRODUCTION
    # NOTE: Staging deploy is handled by ci.yml Stage 7 (deploy-staging).
    # This job promotes the already-staged image to production after
    # manual approval via GitHub Environment protection rules.
    #
    # Requires manual approval via GitHub Environment protection rules.
    # Set up: GitHub repo â†’ Settings â†’ Environments â†’ production
    #         â†’ Enable "Required reviewers" â†’ add yourself
    #
    # Environment secrets required (set in GitHub repo â†’ Environments â†’ production):
    #   DEPLOY_HOST      â€” production server SSH host
    #   DEPLOY_USER      â€” SSH user
    #   DEPLOY_SSH_KEY   â€” Private SSH key
    #   GHCR_READ_TOKEN  â€” GitHub PAT with read:packages scope
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    deploy-production:
        name: Deploy â†’ Production
        runs-on: ubuntu-latest
        needs: [build-and-push]
        environment:
            name: production
            url: ${{ vars.PRODUCTION_URL }}

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Deploy to production server via SSH
              uses: appleboy/ssh-action@v1.2.5
              with:
                  host: ${{ secrets.DEPLOY_HOST }}
                  username: ${{ secrets.DEPLOY_USER }}
                  key: ${{ secrets.DEPLOY_SSH_KEY }}
                  script: |
                      set -e
                      cd ~/blackjack-application

                      git pull origin main

                      export BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}:${{ needs.build-and-push.outputs.image_tag }}
                      export FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}:${{ needs.build-and-push.outputs.image_tag }}

                      echo "${{ secrets.GHCR_READ_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

                      # Rolling update: pull then recreate with zero-downtime intent
                      docker compose -f docker-compose.prod.yml pull
                      docker compose -f docker-compose.prod.yml up -d --remove-orphans

                      # Health check
                      echo "Waiting for backend health check..."
                      for i in $(seq 1 6); do
                        curl -sf http://localhost:8000/health && echo "Backend healthy." && break
                        echo "Attempt $i failed, retrying in 5s..."
                        sleep 5
                      done

                      # Remove dangling images to keep server disk clean
                      docker image prune -f

            - name: Notify production deploy
              run: |
                  echo "ğŸš€ Production deploy complete â€” image tag: ${{ needs.build-and-push.outputs.image_tag }}"
